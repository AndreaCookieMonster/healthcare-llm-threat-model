const fs = require('fs');

function parseValue(raw) {
  const value = raw.trim();
  if (!value) return '';
  if (value === 'null') return null;
  if (value === 'true') return true;
  if (value === 'false') return false;
  if (value.startsWith('[') && value.endsWith(']')) {
    const inner = value.slice(1, -1).trim();
    if (!inner) return [];
    return inner
      .split(',')
      .map((segment) => parseValue(segment))
      .filter((segment) => segment !== '');
  }
  if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
    return value.slice(1, -1);
  }
  if (!Number.isNaN(Number(value))) {
    return Number(value);
  }
  return value;
}

function parseMultilineString(lines, start) {
  const parts = [];
  let i = start;
  let began = false;
  while (i < lines.length) {
    const line = lines[i];
    if (!line.startsWith('  ') || line.startsWith('  - ')) {
      break;
    }
    let trimmed = line.trim();
    if (!began && trimmed.startsWith("'")) {
      trimmed = trimmed.slice(1);
      began = true;
    }
    const nextLine = lines[i + 1] || '';
    if ((!nextLine.startsWith('  ') || nextLine.startsWith('  - ')) && trimmed.endsWith("'")) {
      trimmed = trimmed.slice(0, -1);
    }
    if (trimmed) {
      parts.push(trimmed);
    }
    i += 1;
  }
  return { value: parts.join('\n'), nextIndex: i };
}

function parseBlock(lines, start) {
  const list = [];
  let i = start;
  while (i < lines.length) {
    const line = lines[i];
    if (!line.trim()) {
      i += 1;
      continue;
    }
    if (!line.startsWith('  - ')) break;
    const item = {};
    let currentLine = line.slice(4);
    if (currentLine.includes(':')) {
      const [key, rest] = currentLine.split(':', 2);
      item[key.trim()] = parseValue(rest);
    }
    i += 1;
    while (i < lines.length && lines[i].startsWith('    ')) {
      const subLine = lines[i].trim();
      if (subLine.includes(':')) {
        const [sKey, sRest] = subLine.split(':', 2);
        item[sKey.trim()] = parseValue(sRest);
      }
      i += 1;
    }
    list.push(item);
  }
  return { value: list, nextIndex: i };
}

function parseFrontMatter(text) {
  const trimmed = text.trimEnd();
  const match = /^---\n([\s\S]*?)\n---\n?([\s\S]*)$/m.exec(trimmed);
  if (!match) {
    return { data: {}, content: text };
  }
  const yaml = match[1];
  const content = match[2] || '';
  const lines = yaml.split(/\r?\n/);
  const data = {};
  let i = 0;
  while (i < lines.length) {
    const line = lines[i];
    if (!line.trim()) {
      i += 1;
      continue;
    }
    if (line.startsWith('  - ')) {
      i += 1;
      continue;
    }
    const idx = line.indexOf(':');
    if (idx === -1) {
      i += 1;
      continue;
    }
    const key = line.slice(0, idx).trim();
    const rest = line.slice(idx + 1);
    if (!rest.trim()) {
      const nextLine = lines[i + 1] || '';
      if (nextLine.startsWith('  - ')) {
        const block = parseBlock(lines, i + 1);
        data[key] = block.value;
        i = block.nextIndex;
        continue;
      }
      if (nextLine.startsWith('  ')) {
        const block = parseMultilineString(lines, i + 1);
        data[key] = block.value;
        i = block.nextIndex;
        continue;
      }
      data[key] = '';
      i += 1;
      continue;
    }
    data[key] = parseValue(rest);
    i += 1;
  }
  return { data, content };
}

function matter(input) {
  if (typeof input !== 'string') {
    throw new TypeError('gray-matter stub expects a string');
  }
  return parseFrontMatter(input);
}

matter.read = function read(filePath, options) {
  const encoding = (options && options.encoding) || 'utf8';
  const content = fs.readFileSync(filePath, encoding);
  const parsed = matter(content);
  parsed.path = filePath;
  return parsed;
};

module.exports = matter;
